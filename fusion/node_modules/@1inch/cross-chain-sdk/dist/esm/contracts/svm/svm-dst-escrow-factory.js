import { BorshCoder } from '@coral-xyz/anchor';
import assert from 'assert';
import { Instruction } from './instruction.js';
import { BaseProgram } from './base-program.js';
import { WhitelistContract } from './whitelist.js';
import { bigintToBN } from '../../utils/numbers/bigint-to-bn.js';
import { uintAsBeBytes } from '../../utils/numbers/uint-as-be-bytes.js';
import { uint256split } from '../../utils/numbers/uint256-split.js';
import { getAta, getPda } from '../../utils/index.js';
import { HashLock, SolanaAddress, TimeLocks } from '../../domains/index.js';
import { IDL } from '../../idl/cross-chain-escrow-dst.js';
import { bufferToHex } from '../../utils/bytes.js';
import { bnArrayToBigInt } from '../../utils/numbers/bn-array-to-big-int.js';
import { BN } from '../../utils/numbers/bn.js';
export class SvmDstEscrowFactory extends BaseProgram {
    static DEFAULT = new SvmDstEscrowFactory(new SolanaAddress('AMEAktCrii7mVFQKCM9i5hKES4YrV3zFagrawr8BY8pb'));
    static coder = new BorshCoder(IDL);
    constructor(programId) {
        super(programId);
    }
    static parseCreateEscrowInstruction(ix) {
        const decoded = SvmDstEscrowFactory.coder.instruction.decode(ix.data);
        assert(decoded, 'cannot decode create instruction');
        assert(decoded.name === 'create', 'not create instruction');
        const data = decoded.data;
        return {
            orderHash: bufferToHex(data.orderHash),
            hashlock: HashLock.fromString(bufferToHex(data.hashlock)),
            amount: BigInt(data.amount.toString()),
            safetyDeposit: BigInt(data.safetyDeposit.toString()),
            recipient: SolanaAddress.fromBuffer(data.recipient.toBuffer()),
            timelocks: TimeLocks.fromBigInt(bnArrayToBigInt(data.timelocks)),
            srcCancellationTimestamp: data.srcCancellationTimestamp,
            assetIsNative: data.assetIsNative,
            taker: ix.accounts[0].pubkey,
            token: ix.accounts[1].pubkey,
            escrow: ix.accounts[3].pubkey
        };
    }
    static parsePrivateWithdrawInstruction(ix) {
        const decoded = this.coder.instruction.decode(ix.data);
        assert(decoded, 'cannot decode withdraw instruction');
        assert(decoded.name === 'withdraw', 'not withdraw instruction');
        return {
            secret: bufferToHex(decoded.data.secret)
        };
    }
    static parsePublicWithdrawInstruction(ix) {
        const decoded = this.coder.instruction.decode(ix.data);
        assert(decoded, 'cannot decode publicWithdraw instruction');
        assert(decoded.name === 'publicWithdraw', 'not publicWithdraw instruction');
        return {
            secret: bufferToHex(decoded.data.secret)
        };
    }
    getEscrowAddress(params) {
        return getPda(this.programId, [
            this.encoder.encode('escrow'),
            params.orderHash,
            params.hashLock.toBuffer(),
            params.taker.toBuffer(),
            uintAsBeBytes(params.amount, 64)
        ]);
    }
    createEscrow(params, extra) {
        const token = params.token.isNative()
            ? SolanaAddress.WRAPPED_NATIVE
            : params.token;
        const data = SvmDstEscrowFactory.coder.instruction.encode('create', {
            orderHash: params.orderHash,
            hashlock: params.hashLock.toBuffer(),
            amount: new BN(params.amount.toString()),
            safetyDeposit: new BN(params.safetyDeposit.toString()),
            recipient: params.maker,
            timelocks: uint256split(params.timeLocks.build()).map(bigintToBN),
            srcCancellationTimestamp: Number(extra.srcCancellationTimestamp),
            assetIsNative: params.token.isNative()
        });
        const escrowAddress = this.getEscrowAddress(params);
        return new Instruction(this.programId, [
            {
                // 1. taker
                pubkey: params.taker,
                isSigner: true,
                isWritable: true
            },
            {
                // 2. mint
                pubkey: token,
                isWritable: false,
                isSigner: false
            },
            this.optionalAccount({
                // 3. taker_ata
                pubkey: getAta(params.taker, token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, params.token.isNative()),
            {
                // 4. escrow
                pubkey: escrowAddress,
                isSigner: false,
                isWritable: true
            },
            {
                // 5. escrow ata
                pubkey: getAta(escrowAddress, token, extra.tokenProgramId),
                isWritable: true,
                isSigner: false
            },
            {
                // 6. associated_token_program
                pubkey: SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            {
                // 7. token_program
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            {
                // 8. rent
                pubkey: SolanaAddress.SYSVAR_RENT_ID,
                isSigner: false,
                isWritable: false
            },
            {
                // 9. system_program
                pubkey: SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    withdrawPrivate(params, secret, extra) {
        const token = params.token.isNative()
            ? SolanaAddress.WRAPPED_NATIVE
            : params.token;
        const data = SvmDstEscrowFactory.coder.instruction.encode('withdraw', {
            secret
        });
        const escrow = this.getEscrowAddress(params);
        return new Instruction(this.programId, [
            {
                // 1. taker
                pubkey: params.taker,
                isSigner: true,
                isWritable: true
            },
            {
                // 2. recipient
                pubkey: params.maker,
                isSigner: false,
                isWritable: true
            },
            {
                // 3. dst token
                pubkey: token,
                isSigner: false,
                isWritable: false
            },
            {
                // 4. escrow
                pubkey: escrow,
                isSigner: false,
                isWritable: true
            },
            {
                // 5. escrow_ata
                pubkey: getAta(escrow, token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            this.optionalAccount({
                // 6. recipient_ata
                pubkey: getAta(params.maker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, params.token.isNative()),
            {
                // 7. associated_token_program
                pubkey: SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            {
                // 8. token_program
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            {
                // 9. system_program
                pubkey: SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    withdrawPublic(params, secret, payer, extra) {
        const whitelistProgram = extra.whitelistProgramId
            ? new WhitelistContract(extra.whitelistProgramId)
            : WhitelistContract.DEFAULT;
        const token = params.token.isNative()
            ? SolanaAddress.WRAPPED_NATIVE
            : params.token;
        const data = SvmDstEscrowFactory.coder.instruction.encode('publicWithdraw', { secret });
        const escrow = this.getEscrowAddress(params);
        return new Instruction(this.programId, [
            {
                // 1. creator
                pubkey: params.taker,
                isSigner: false,
                isWritable: true
            },
            {
                // 2. recipient
                pubkey: params.maker,
                isSigner: false,
                isWritable: true
            },
            {
                // 3. payer
                pubkey: payer,
                isSigner: true,
                isWritable: true
            },
            {
                // 4. resolver_access
                pubkey: whitelistProgram.getAccessAccount(payer),
                isSigner: false,
                isWritable: false
            },
            {
                // 5. mint
                pubkey: token,
                isSigner: false,
                isWritable: false
            },
            {
                // 6. escrow
                pubkey: escrow,
                isSigner: false,
                isWritable: true
            },
            {
                // 7. escrow_ata
                pubkey: getAta(escrow, token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            this.optionalAccount({
                // 8. recipient_ata
                pubkey: getAta(params.maker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, params.token.isNative()),
            {
                // 9. associated_token_program
                pubkey: SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            {
                // 10. token_program
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            {
                // 11. system_program
                pubkey: SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    cancelPrivate(params, extra) {
        const token = params.token.isNative()
            ? SolanaAddress.WRAPPED_NATIVE
            : params.token;
        const data = SvmDstEscrowFactory.coder.instruction.encode('cancel', {});
        const escrow = this.getEscrowAddress(params);
        return new Instruction(this.programId, [
            {
                // 1. creator
                pubkey: params.taker,
                isSigner: true,
                isWritable: true
            },
            {
                // 2. mint
                pubkey: token,
                isSigner: false,
                isWritable: false
            },
            {
                // 3. escrow
                pubkey: escrow,
                isSigner: false,
                isWritable: true
            },
            {
                // 4. escrow_ata
                pubkey: getAta(escrow, token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            this.optionalAccount({
                // 5. creator_ata
                pubkey: getAta(params.taker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, params.token.isNative()),
            {
                // 6. token_program
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            {
                // 7. system_program
                pubkey: SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
}
//# sourceMappingURL=svm-dst-escrow-factory.js.map