import bs58 from 'bs58';
import { hexToUint8Array, uint8ArrayToHex } from '@1inch/byte-utils';
import { hexlify } from 'ethers';
import { UINT_160_MAX } from '@1inch/fusion-sdk';
import { AddressComplement } from './address-complement.js';
import { EvmAddress } from './evm-address.js';
import { isBigintString } from '../../utils/numbers/is-bigint-string.js';
export class SolanaAddress {
    static ASSOCIATED_TOKE_PROGRAM_ID = new SolanaAddress('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
    static TOKEN_PROGRAM_ID = new SolanaAddress('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    static TOKEN_2022_PROGRAM_ID = new SolanaAddress('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');
    static SYSTEM_PROGRAM_ID = new SolanaAddress('11111111111111111111111111111111');
    static SYSVAR_RENT_ID = new SolanaAddress('SysvarRent111111111111111111111111111111111');
    static ZERO = SolanaAddress.fromBigInt(0n);
    static WRAPPED_NATIVE = new SolanaAddress('So11111111111111111111111111111111111111112');
    static NATIVE = new SolanaAddress('SoNative11111111111111111111111111111111111');
    buf;
    constructor(value) {
        try {
            this.buf = bs58.decode(value);
            if (this.buf.length !== 32) {
                throw '';
            }
        }
        catch {
            throw new Error(`${value} is not a valid address.`);
        }
    }
    static fromString(str) {
        return new SolanaAddress(str);
    }
    /**
     * @see splitToParts
     */
    static fromParts(parts) {
        const highBits = parts[0].inner;
        const lowBits = parts[1].toBigint();
        const address = (highBits << 160n) | lowBits;
        return SolanaAddress.fromBigInt(address);
    }
    static fromUnknown(val) {
        if (!val) {
            throw new Error('invalid address');
        }
        if (typeof val === 'string') {
            if (isBigintString(val)) {
                return SolanaAddress.fromBigInt(BigInt(val));
            }
            return new SolanaAddress(val);
        }
        if (typeof val === 'bigint') {
            return SolanaAddress.fromBigInt(val);
        }
        if (typeof val === 'object' &&
            'toBuffer' in val &&
            typeof val.toBuffer === 'function') {
            const buffer = val.toBuffer();
            if (buffer instanceof Buffer || buffer instanceof Uint8Array) {
                return SolanaAddress.fromBuffer(buffer);
            }
        }
        throw new Error('invalid address');
    }
    static fromPublicKey(publicKey) {
        return SolanaAddress.fromBuffer(publicKey.toBuffer());
    }
    static fromBuffer(buf) {
        return new SolanaAddress(bs58.encode(buf));
    }
    static fromBigInt(val) {
        const buffer = hexToUint8Array('0x' + val.toString(16).padStart(64, '0'));
        return SolanaAddress.fromBuffer(buffer);
    }
    nativeAsZero() {
        return this;
    }
    zeroAsNative() {
        return this;
    }
    toString() {
        return bs58.encode(this.buf);
    }
    toJSON() {
        return this.toString();
    }
    toBuffer() {
        return Buffer.from(this.buf);
    }
    equal(other) {
        return this.toBuffer().equals(other.toBuffer());
    }
    isNative() {
        return this.equal(SolanaAddress.NATIVE);
    }
    isZero() {
        return this.equal(SolanaAddress.ZERO);
    }
    toHex() {
        return hexlify(this.toBuffer());
    }
    toBigint() {
        return BigInt(uint8ArrayToHex(this.buf));
    }
    splitToParts() {
        const bn = this.toBigint();
        return [
            new AddressComplement(bn >> 160n),
            EvmAddress.fromBigInt(bn & UINT_160_MAX)
        ];
    }
}
//# sourceMappingURL=solana-address.js.map