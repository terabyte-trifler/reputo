import { AbiCoder, keccak256 } from 'ethers';
import { add0x, isHexBytes } from '@1inch/byte-utils';
import assert from 'assert';
import { HashLock } from '../hash-lock/index.js';
import { TimeLocks } from '../time-locks/index.js';
import { EvmAddress, SolanaAddress } from '../../domains/addresses/index.js';
import { bufferFromHex } from '../../utils/bytes.js';
/**
 * Contains escrow params for both source and destination chains
 * Determinate addresses of escrow contracts
 */
export class Immutables {
    orderHash;
    hashLock;
    maker;
    taker;
    token;
    amount;
    safetyDeposit;
    timeLocks;
    static Web3Type = `tuple(${[
        'bytes32 orderHash',
        'bytes32 hashlock',
        'address maker',
        'address taker',
        'address token',
        'uint256 amount',
        'uint256 safetyDeposit',
        'uint256 timelocks'
    ]})`;
    constructor(orderHash, hashLock, maker, 
    /**
     * Address who can withdraw funds, also to this address funds will be transferred in case of public withdrawal
     */
    taker, token, amount, safetyDeposit, timeLocks) {
        this.orderHash = orderHash;
        this.hashLock = hashLock;
        this.maker = maker;
        this.taker = taker;
        this.token = token;
        this.amount = amount;
        this.safetyDeposit = safetyDeposit;
        this.timeLocks = timeLocks;
        this.token = this.token.zeroAsNative();
    }
    static new(params) {
        return new Immutables(params.orderHash, params.hashLock, params.maker, params.taker, params.token, params.amount, params.safetyDeposit, params.timeLocks);
    }
    /**
     * Create instance from encoded bytes
     * @param bytes 0x prefixed hex string
     */
    static fromABIEncoded(bytes) {
        assert(isHexBytes(bytes));
        const res = AbiCoder.defaultAbiCoder().decode([Immutables.Web3Type], bytes);
        const data = res.at(0);
        return Immutables.fromJSON(data);
    }
    static fromJSON(data) {
        const isSolanaAddress = data.maker.length === 66;
        const isEvmAddress = data.maker.length === 42;
        assert(isSolanaAddress || isEvmAddress, 'invalid addresses length');
        if (isSolanaAddress) {
            assert(data.taker.length === 66, 'invalid solana taker address len');
            assert(data.token.length === 66, 'invalid solana token address len');
        }
        if (isEvmAddress) {
            assert(data.taker.length === 42, 'invalid solana taker address len');
            assert(data.token.length === 42, 'invalid solana token address len');
        }
        const TypedAddress = isSolanaAddress ? SolanaAddress : EvmAddress;
        return new Immutables(bufferFromHex(data.orderHash), HashLock.fromString(data.hashlock), TypedAddress.fromBuffer(bufferFromHex(data.maker)), TypedAddress.fromBuffer(bufferFromHex(data.taker)), TypedAddress.fromBuffer(bufferFromHex(data.token)), BigInt(data.amount), BigInt(data.safetyDeposit), TimeLocks.fromBigInt(BigInt(data.timelocks)));
    }
    toJSON() {
        return this.build();
    }
    withComplement(dstComplement) {
        return Immutables.new({ ...this, ...dstComplement });
    }
    withDeployedAt(time) {
        return Immutables.new({
            ...this,
            timeLocks: TimeLocks.fromBigInt(this.timeLocks.build()).setDeployedAt(time)
        });
    }
    withTaker(taker) {
        return Immutables.new({ ...this, taker });
    }
    withHashLock(hashLock) {
        return Immutables.new({ ...this, hashLock });
    }
    withAmount(amount) {
        return Immutables.new({ ...this, amount });
    }
    /**
     * Return keccak256 hash of instance
     */
    hash() {
        return keccak256(this.toABIEncoded());
    }
    build() {
        const token = this.token.nativeAsZero();
        return {
            orderHash: add0x(this.orderHash.toString('hex')),
            hashlock: this.hashLock.toString(),
            maker: this.maker.toHex(),
            taker: this.taker.toHex(),
            token: token.toHex(),
            amount: this.amount.toString(),
            safetyDeposit: this.safetyDeposit.toString(),
            timelocks: this.timeLocks.build().toString()
        };
    }
    /**
     * Encode instance as bytes
     */
    toABIEncoded() {
        return AbiCoder.defaultAbiCoder().encode([Immutables.Web3Type], [this.build()]);
    }
}
//# sourceMappingURL=immutables.js.map