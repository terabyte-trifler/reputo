import { isValidAmount } from '@1inch/fusion-sdk';
import assert from 'assert';
import { isEvm, isSolana } from '../../chains.js';
import { createAddress, EvmAddress, SolanaAddress } from '../../domains/index.js';
export class QuoterRequest {
    srcChain;
    dstChain;
    srcTokenAddress;
    dstTokenAddress;
    amount;
    walletAddress;
    enableEstimate;
    permit;
    fee;
    source;
    isPermit2;
    // eslint-disable-next-line max-params
    constructor(srcChain, dstChain, srcTokenAddress, dstTokenAddress, amount, walletAddress, enableEstimate = false, permit, fee, source = 'sdk', isPermit2 = false) {
        this.srcChain = srcChain;
        this.dstChain = dstChain;
        this.srcTokenAddress = srcTokenAddress;
        this.dstTokenAddress = dstTokenAddress;
        this.amount = amount;
        this.walletAddress = walletAddress;
        this.enableEstimate = enableEstimate;
        this.permit = permit;
        this.fee = fee;
        this.source = source;
        this.isPermit2 = isPermit2;
        if (srcChain === dstChain) {
            throw new Error('srcChain and dstChain should be different');
        }
        if (this.fee && this.source === 'sdk') {
            throw new Error('cannot use fee without source');
        }
    }
    static isEvmRequest(params) {
        return isEvm(params.srcChain);
    }
    static isSolanaRequest(params) {
        return isSolana(params.srcChain);
    }
    static forEVM(params) {
        assert(isEvm(params.srcChain), 'cannot use non evm quote request for srcChain');
        assert(isValidAmount(params.amount), `${params.amount} is invalid amount`);
        const srcToken = EvmAddress.fromString(params.srcTokenAddress);
        const dstToken = createAddress(params.dstTokenAddress, params.dstChain);
        assert(!srcToken.isNative(), `cannot swap ${EvmAddress.NATIVE}: wrap native currency to it's wrapper fist`);
        if (isEvm(params.dstChain)) {
            assert(!dstToken.isZero(), `replace ${EvmAddress.ZERO} with ${EvmAddress.NATIVE}`);
        }
        return new QuoterRequest(params.srcChain, params.dstChain, srcToken, dstToken, BigInt(params.amount), EvmAddress.fromString(params.walletAddress), params.enableEstimate, params.permit, params.fee, params.source, params.isPermit2);
    }
    static forSolana(params) {
        assert(isSolana(params.srcChain), 'cannot use non solana quote request for srcChain');
        assert(isValidAmount(params.amount), `${params.amount} is invalid amount`);
        const srcToken = SolanaAddress.fromString(params.srcTokenAddress);
        const dstToken = createAddress(params.dstTokenAddress, params.dstChain);
        return new QuoterRequest(params.srcChain, params.dstChain, srcToken, dstToken, BigInt(params.amount), SolanaAddress.fromString(params.walletAddress), params.enableEstimate, params.permit, params.fee, params.source, params.isPermit2);
    }
    isEvmRequest() {
        return isEvm(this.srcChain);
    }
    isSolanaRequest() {
        return isSolana(this.srcChain);
    }
    build() {
        return {
            srcChain: this.srcChain,
            dstChain: this.dstChain,
            srcTokenAddress: this.srcTokenAddress.toString(),
            dstTokenAddress: this.dstTokenAddress.toString(),
            amount: this.amount.toString(),
            walletAddress: this.walletAddress.toString(),
            enableEstimate: this.enableEstimate,
            permit: this.permit,
            fee: this.fee,
            source: this.source,
            isPermit2: this.isPermit2
        };
    }
}
//# sourceMappingURL=quoter.request.js.map