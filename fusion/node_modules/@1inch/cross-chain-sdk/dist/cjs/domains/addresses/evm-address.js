"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmAddress = void 0;
const ethers_1 = require("ethers");
const fusion_sdk_1 = require("@1inch/fusion-sdk");
const address_complement_js_1 = require("./address-complement.js");
const is_bigint_string_js_1 = require("../../utils/numbers/is-bigint-string.js");
const bytes_js_1 = require("../../utils/bytes.js");
class EvmAddress {
    inner;
    static ZERO = new EvmAddress(fusion_sdk_1.Address.ZERO_ADDRESS);
    static NATIVE = new EvmAddress(fusion_sdk_1.Address.NATIVE_CURRENCY);
    constructor(inner) {
        this.inner = inner;
    }
    static fromBigInt(val) {
        return new EvmAddress(fusion_sdk_1.Address.fromBigInt(val));
    }
    static fromString(address) {
        return new EvmAddress(new fusion_sdk_1.Address(address));
    }
    static fromBuffer(address) {
        const hex = '0x' +
            address
                .toString('hex')
                .substring(address.length * 2 - 40, address.length * 2);
        return new EvmAddress(new fusion_sdk_1.Address(hex));
    }
    static fromUnknown(address) {
        if (typeof address === 'string') {
            if ((0, ethers_1.isAddress)(address)) {
                return EvmAddress.fromString(address);
            }
            if ((0, is_bigint_string_js_1.isBigintString)(address)) {
                return EvmAddress.fromBigInt(BigInt(address));
            }
        }
        if (typeof address == 'bigint') {
            return EvmAddress.fromBigInt(address);
        }
        throw new Error(`Unknown address: ${address}`);
    }
    /**
     * @see zeroAsNative
     * @returns same address if current address is non native and zero address otherwise
     */
    nativeAsZero() {
        // because on contract side native address represent as zero address
        if (this.isNative()) {
            return EvmAddress.ZERO;
        }
        return this;
    }
    /**
     * @see nativeAsZero
     * @returns same address if current address is non zero and 0xee..ee otherwise
     */
    zeroAsNative() {
        // because on contract side native address represent as zero address
        if (this.isZero()) {
            return EvmAddress.NATIVE;
        }
        return this;
    }
    toBuffer() {
        return (0, bytes_js_1.bufferFromHex)(this.toString());
    }
    toHex() {
        return this.inner.toString();
    }
    equal(other) {
        return this.inner.toString() === other.toString();
    }
    isNative() {
        return this.inner.isNative();
    }
    isZero() {
        return this.inner.isZero();
    }
    toBigint() {
        return BigInt(this.inner.toString());
    }
    toString() {
        return this.inner.toString();
    }
    toJSON() {
        return this.inner.toString();
    }
    splitToParts() {
        return [address_complement_js_1.AddressComplement.ZERO, this];
    }
}
exports.EvmAddress = EvmAddress;
//# sourceMappingURL=evm-address.js.map