"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmCrossChainOrder = void 0;
const fusion_sdk_1 = require("@1inch/fusion-sdk");
const assert_1 = __importDefault(require("assert"));
const inner_order_js_1 = require("./inner-order.js");
const escrow_extension_js_1 = require("./escrow-extension.js");
const address_complement_js_1 = require("../../domains/addresses/address-complement.js");
const index_js_1 = require("../../utils/time/index.js");
const index_js_2 = require("../../domains/addresses/index.js");
const base_order_js_1 = require("../base-order.js");
const deployments_js_1 = require("../../deployments.js");
const chains_js_1 = require("../../chains.js");
const bytes_js_1 = require("../../utils/bytes.js");
class EvmCrossChainOrder extends base_order_js_1.BaseOrder {
    inner;
    constructor(extension, orderInfo, extra) {
        super();
        this.inner = new inner_order_js_1.InnerOrder(extension, orderInfo, extra);
    }
    get hashLock() {
        return this.escrowExtension.hashLockInfo;
    }
    get timeLocks() {
        return this.escrowExtension.timeLocks;
    }
    get srcSafetyDeposit() {
        return this.escrowExtension.srcSafetyDeposit;
    }
    get dstSafetyDeposit() {
        return this.escrowExtension.dstSafetyDeposit;
    }
    get dstChainId() {
        return this.inner.escrowExtension.dstChainId;
    }
    get escrowExtension() {
        return this.inner.escrowExtension;
    }
    get extension() {
        return this.inner.extension;
    }
    get maker() {
        return index_js_2.EvmAddress.fromString(this.inner.maker.toString());
    }
    get takerAsset() {
        return (0, index_js_2.createAddress)(this.inner.escrowExtension.dstToken.toString(), this.dstChainId);
    }
    get makerAsset() {
        return index_js_2.EvmAddress.fromString(this.inner.makerAsset.toString());
    }
    get takingAmount() {
        return this.inner.takingAmount;
    }
    get makingAmount() {
        return this.inner.makingAmount;
    }
    get salt() {
        return this.inner.salt;
    }
    /**
     * Real receiver of funds on dst chain
     */
    get receiver() {
        const receiver = (0, index_js_2.createAddress)(this.inner.receiver.toString(), this.dstChainId, this.escrowExtension.dstAddressFirstPart);
        return receiver.isZero() ? this.maker : receiver;
    }
    /**
     * Timestamp in sec
     */
    get deadline() {
        return this.inner.deadline;
    }
    /**
     * Timestamp in sec
     */
    get auctionStartTime() {
        return this.inner.auctionStartTime;
    }
    /**
     * Timestamp in sec
     */
    get auctionEndTime() {
        return this.inner.auctionEndTime;
    }
    get nonce() {
        return this.inner.nonce;
    }
    get partialFillAllowed() {
        return this.inner.partialFillAllowed;
    }
    get multipleFillsAllowed() {
        return this.inner.multipleFillsAllowed;
    }
    /**
     * Create new EvmCrossChainOrder
     */
    static new(escrowFactory, orderInfo, escrowParams, details, extra) {
        (0, assert_1.default)((0, chains_js_1.isEvm)(escrowParams.srcChainId), `Not supported chain ${escrowParams.srcChainId}`);
        (0, assert_1.default)((0, chains_js_1.isSupportedChain)(escrowParams.dstChainId), `Not supported chain ${escrowParams.dstChainId}`);
        (0, assert_1.default)(escrowParams.srcChainId !== escrowParams.dstChainId, 'Chains must be different');
        const postInteractionData = fusion_sdk_1.SettlementPostInteractionData.new({
            whitelist: details.whitelist.map((i) => ({
                address: i.address.inner,
                allowFrom: i.allowFrom
            })),
            resolvingStartTime: details.resolvingStartTime ?? BigInt((0, index_js_1.now)())
        });
        if (!(0, chains_js_1.isEvm)(escrowParams.dstChainId) && !orderInfo.receiver) {
            throw new Error('Receiver is required for non EVM chain');
        }
        const [complement, receiver] = orderInfo.receiver?.splitToParts() || [
            address_complement_js_1.AddressComplement.ZERO,
            index_js_2.EvmAddress.ZERO
        ];
        const ext = new escrow_extension_js_1.EscrowExtension(escrowFactory, details.auction, postInteractionData, extra?.permit
            ? new fusion_sdk_1.Interaction(orderInfo.makerAsset.inner, extra.permit)
            : undefined, escrowParams.hashLock, escrowParams.dstChainId, orderInfo.takerAsset, escrowParams.srcSafetyDeposit, escrowParams.dstSafetyDeposit, escrowParams.timeLocks, complement);
        return new EvmCrossChainOrder(ext, {
            ...orderInfo,
            receiver,
            takerAsset: deployments_js_1.TRUE_ERC20[escrowParams.srcChainId]
        }, extra);
    }
    /**
     * Create CrossChainOrder from order data and extension
     *
     */
    static fromDataAndExtension(order, extension) {
        const ext = escrow_extension_js_1.EscrowExtension.fromExtension(extension);
        const makerTraits = new fusion_sdk_1.MakerTraits(BigInt(order.makerTraits));
        const deadline = makerTraits.expiration();
        const orderExpirationDelay = deadline === null
            ? undefined
            : deadline -
                ext.auctionDetails.startTime -
                ext.auctionDetails.duration;
        return new EvmCrossChainOrder(ext, {
            makerAsset: index_js_2.EvmAddress.fromUnknown(order.makerAsset),
            takerAsset: index_js_2.EvmAddress.fromUnknown(order.takerAsset),
            makingAmount: BigInt(order.makingAmount),
            takingAmount: BigInt(order.takingAmount),
            receiver: index_js_2.EvmAddress.fromUnknown(order.receiver),
            maker: index_js_2.EvmAddress.fromUnknown(order.maker),
            salt: BigInt(order.salt) >> 160n
        }, {
            enablePermit2: makerTraits.isPermit2(),
            nonce: makerTraits.nonceOrEpoch(),
            permit: extension.makerPermit === fusion_sdk_1.ZX
                ? undefined
                : fusion_sdk_1.Interaction.decode(extension.makerPermit).data,
            orderExpirationDelay,
            allowMultipleFills: makerTraits.isMultipleFillsAllowed(),
            allowPartialFills: makerTraits.isPartialFillAllowed()
        });
    }
    build() {
        return this.inner.build();
    }
    toJSON() {
        return this.build();
    }
    getOrderHash(srcChainId) {
        return this.inner.getOrderHash(srcChainId);
    }
    getOrderHashBuffer(srcChainId) {
        return (0, bytes_js_1.bufferFromHex)(this.getOrderHash(srcChainId));
    }
    getTypedData(srcChainId) {
        return this.inner.getTypedData(srcChainId);
    }
    getCalculator() {
        return this.inner.getCalculator();
    }
    /**
     * Check if `wallet` can fill order before other
     */
    isExclusiveResolver(wallet) {
        return this.inner.isExclusiveResolver(wallet.inner);
    }
    /**
     * Check if the auction has exclusive resolver, and it is in the exclusivity period
     *
     * @param time timestamp to check, `now()` by default
     */
    isExclusivityPeriod(time) {
        return this.inner.isExclusivityPeriod(time);
    }
    /**
     * Check whether address allowed to execute order at the given time
     *
     * @param executor address of executor
     * @param executionTime timestamp in sec at which order planning to execute
     */
    canExecuteAt(executor, executionTime) {
        return this.inner.canExecuteAt(executor.inner, executionTime);
    }
}
exports.EvmCrossChainOrder = EvmCrossChainOrder;
//# sourceMappingURL=evm-cross-chain-order.js.map