"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SvmSrcEscrowFactory = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const assert_1 = __importDefault(require("assert"));
const buffer_1 = require("buffer");
const instruction_js_1 = require("./instruction.js");
const base_program_js_1 = require("./base-program.js");
const whitelist_js_1 = require("./whitelist.js");
const chains_js_1 = require("../../chains.js");
const uint_as_be_bytes_js_1 = require("../../utils/numbers/uint-as-be-bytes.js");
const index_js_1 = require("../../domains/index.js");
const index_js_2 = require("../../utils/index.js");
const cross_chain_escrow_src_js_1 = require("../../idl/cross-chain-escrow-src.js");
const uint256_split_js_1 = require("../../utils/numbers/uint256-split.js");
const hasher_js_1 = require("../../domains/auction-details/hasher.js");
const bigint_to_bn_js_1 = require("../../utils/numbers/bigint-to-bn.js");
const bytes_js_1 = require("../../utils/bytes.js");
const bn_array_to_big_int_js_1 = require("../../utils/numbers/bn-array-to-big-int.js");
const index_js_3 = require("../../cross-chain-order/index.js");
const u24_to_number_js_1 = require("../../utils/numbers/u24-to-number.js");
const bn_js_1 = require("../../utils/numbers/bn.js");
class SvmSrcEscrowFactory extends base_program_js_1.BaseProgram {
    static DEFAULT = new SvmSrcEscrowFactory(new index_js_1.SolanaAddress('4yBT18tBcWqCDK8p3RMXdmZMjHr3wJM7jM6HVYemEqGh'));
    static coder = new anchor_1.BorshCoder(cross_chain_escrow_src_js_1.IDL);
    constructor(programId) {
        super(programId);
    }
    static parseCreateInstruction(ix) {
        const decodeIx = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decodeIx, 'cannot decode create instruction');
        (0, assert_1.default)(decodeIx.name === 'create', 'provided not create instruction');
        const data = decodeIx.data;
        const accounts = {
            creator: ix.accounts[0].pubkey,
            mint: ix.accounts[1].pubkey,
            creatorAta: ix.accounts[2].pubkey,
            order: ix.accounts[3].pubkey,
            orderAta: ix.accounts[4].pubkey,
            associatedTokenProgram: ix.accounts[5].pubkey,
            tokenProgram: ix.accounts[6].pubkey,
            rent: ix.accounts[7].pubkey,
            systemProgram: ix.accounts[8].pubkey
        };
        const orderInfo = {
            srcToken: accounts.mint,
            dstToken: index_js_1.EvmAddress.fromBuffer(buffer_1.Buffer.from(data.dstChainParams.token)),
            maker: accounts.creator,
            srcAmount: BigInt(data.amount.toString()),
            minDstAmount: (0, bn_array_to_big_int_js_1.bnArrayToBigInt)(data.dstAmount),
            receiver: index_js_1.EvmAddress.fromBuffer(buffer_1.Buffer.from(data.dstChainParams.makerAddress))
        };
        const escrowParams = {
            hashLock: index_js_1.HashLock.fromBuffer(buffer_1.Buffer.from(data.hashlock)),
            srcChainId: chains_js_1.NetworkEnum.SOLANA,
            dstChainId: data.dstChainParams.chainId,
            srcSafetyDeposit: BigInt(data.safetyDeposit.toString()),
            dstSafetyDeposit: BigInt(data.dstChainParams.safetyDeposit.toString()),
            timeLocks: index_js_1.TimeLocks.fromBigInt((0, bn_array_to_big_int_js_1.bnArrayToBigInt)(data.timelocks))
        };
        const extraDetails = {
            srcAssetIsNative: data.assetIsNative,
            resolverCancellationConfig: new index_js_3.ResolverCancellationConfig(BigInt(data.maxCancellationPremium.toString()), data.cancellationAuctionDuration),
            allowMultipleFills: data.allowMultipleFills,
            salt: BigInt(data.salt.toString())
        };
        return {
            orderInfo,
            escrowParams,
            extra: extraDetails,
            expirationTime: BigInt(data.expirationTime),
            dutchAuctionDataHash: (0, bytes_js_1.bufferToHex)(data.dutchAuctionDataHash)
        };
    }
    static parseCreateEscrowInstruction(ix) {
        const decodeIx = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decodeIx, 'cannot decode create instruction');
        (0, assert_1.default)(decodeIx.name === 'createEscrow', 'not createEscrow instruction');
        const { amount, dutchAuctionData, merkleProof } = decodeIx.data;
        const auction = new index_js_1.AuctionDetails({
            startTime: BigInt(dutchAuctionData.startTime),
            duration: BigInt(dutchAuctionData.duration),
            initialRateBump: (0, u24_to_number_js_1.u24ToNumber)(dutchAuctionData.initialRateBump),
            points: dutchAuctionData.pointsAndTimeDeltas.map((pt) => ({
                coefficient: (0, u24_to_number_js_1.u24ToNumber)(pt.rateBump),
                delay: pt.timeDelta
            }))
        });
        return {
            amount: BigInt(amount.toString()),
            dutchAuctionData: auction,
            merkleProof: merkleProof
                ? {
                    index: Number(merkleProof.index.toString()),
                    proof: merkleProof.proof.map(bytes_js_1.bufferToHex),
                    hashedSecret: (0, bytes_js_1.bufferToHex)(merkleProof.hashedSecret)
                }
                : null,
            taker: ix.accounts[0].pubkey,
            token: ix.accounts[3].pubkey,
            escrow: ix.accounts[6].pubkey
        };
    }
    static parsePrivateWithdrawInstruction(ix) {
        const decoded = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decoded, 'cannot decode withdraw instruction');
        (0, assert_1.default)(decoded.name === 'withdraw', 'not withdraw instruction');
        return {
            secret: (0, bytes_js_1.bufferToHex)(decoded.data.secret)
        };
    }
    static parsePublicWithdrawInstruction(ix) {
        const decoded = this.coder.instruction.decode(ix.data);
        (0, assert_1.default)(decoded, 'cannot decode publicWithdraw instruction');
        (0, assert_1.default)(decoded.name === 'publicWithdraw', 'not publicWithdraw instruction');
        return {
            secret: (0, bytes_js_1.bufferToHex)(decoded.data.secret)
        };
    }
    getOrderAccount(orderHash) {
        return (0, index_js_2.getPda)(this.programId, [this.encoder.encode('order'), orderHash]);
    }
    getEscrowAddress(params) {
        return (0, index_js_2.getPda)(this.programId, [
            this.encoder.encode('escrow'),
            params.orderHash,
            params.hashLock.toBuffer(),
            params.taker.toBuffer(),
            (0, uint_as_be_bytes_js_1.uintAsBeBytes)(params.amount, 64)
        ]);
    }
    createOrder(order, extra) {
        const data = SvmSrcEscrowFactory.coder.instruction.encode('create', {
            hashlock: order.hashLock.toBuffer(),
            amount: new bn_js_1.BN(order.makingAmount.toString()),
            safetyDeposit: new bn_js_1.BN(order.srcSafetyDeposit.toString()),
            timelocks: (0, uint256_split_js_1.uint256split)(order.timeLocks.build()).map(bigint_to_bn_js_1.bigintToBN),
            expirationTime: Number(order.deadline),
            assetIsNative: order.srcAssetIsNative,
            dstAmount: (0, uint256_split_js_1.uint256split)(order.takingAmount).map(bigint_to_bn_js_1.bigintToBN),
            dutchAuctionDataHash: (0, hasher_js_1.hashForSolana)(order.auction),
            maxCancellationPremium: new bn_js_1.BN(order.resolverCancellationConfig.maxCancellationPremium.toString()),
            cancellationAuctionDuration: order.resolverCancellationConfig.cancellationAuctionDuration,
            allowMultipleFills: order.multipleFillsAllowed,
            salt: new bn_js_1.BN(order.salt.toString()),
            dstChainParams: {
                chainId: order.dstChainId,
                makerAddress: (0, bytes_js_1.bufferFromHex)(order.receiver.toString(), 32),
                token: (0, bytes_js_1.bufferFromHex)(order.takerAsset.toString(), 32),
                safetyDeposit: new bn_js_1.BN(order.dstSafetyDeposit.toString())
            }
        });
        const orderAccount = order.getOrderAccount(this.programId);
        return new instruction_js_1.Instruction(this.programId, [
            // 1. maker
            { pubkey: order.maker, isWritable: true, isSigner: true },
            // 2. src mint
            {
                pubkey: order.makerAsset,
                isWritable: false,
                isSigner: false
            },
            // 3. src_maker_ata
            this.optionalAccount({
                pubkey: (0, index_js_2.getAta)(order.maker, order.makerAsset, extra.srcTokenProgramId),
                isSigner: false,
                isWritable: true
            }, order.srcAssetIsNative),
            // 4. order
            {
                pubkey: orderAccount,
                isSigner: false,
                isWritable: true
            },
            // 5. order_ata
            {
                pubkey: (0, index_js_2.getAta)(orderAccount, order.makerAsset, extra.srcTokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 6. associated_token_program
            {
                pubkey: index_js_1.SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            // 7. token_program
            {
                pubkey: extra.srcTokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 8. rent
            {
                pubkey: index_js_1.SolanaAddress.SYSVAR_RENT_ID,
                isSigner: false,
                isWritable: false
            },
            // 9. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    createEscrow(immutables, auction, extra) {
        const merkleProof = extra.merkleProof || null;
        const whitelistProgram = extra.whitelistProgramId
            ? new whitelist_js_1.WhitelistContract(extra.whitelistProgramId)
            : whitelist_js_1.WhitelistContract.DEFAULT;
        const data = SvmSrcEscrowFactory.coder.instruction.encode('createEscrow', {
            amount: new bn_js_1.BN(immutables.amount.toString()),
            dutchAuctionData: {
                startTime: Number(auction.startTime),
                duration: Number(auction.duration),
                initialRateBump: [
                    (0, uint_as_be_bytes_js_1.uintAsBeBytes)(auction.initialRateBump, 24)
                ],
                pointsAndTimeDeltas: auction.points.map((p) => ({
                    rateBump: [(0, uint_as_be_bytes_js_1.uintAsBeBytes)(BigInt(p.coefficient), 24)],
                    timeDelta: p.delay
                }))
            },
            merkleProof: merkleProof && {
                proof: merkleProof.proof.map((x) => (0, bytes_js_1.bufferFromHex)(x)),
                index: new bn_js_1.BN(merkleProof.idx),
                hashedSecret: merkleProof.secretHash
            }
        });
        const orderAccount = this.getOrderAccount(immutables.orderHash);
        const escrowAddress = this.getEscrowAddress(immutables);
        return new instruction_js_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: immutables.taker,
                isSigner: true,
                isWritable: true
            },
            // 2. resolver_access
            {
                pubkey: whitelistProgram.getAccessAccount(immutables.taker),
                isSigner: false,
                isWritable: false
            },
            // 3. maker
            {
                pubkey: immutables.maker,
                isSigner: false,
                isWritable: true
            },
            // 4. mint
            {
                pubkey: immutables.token,
                isSigner: false,
                isWritable: false
            },
            // 5. order
            {
                pubkey: orderAccount,
                isSigner: false,
                isWritable: true
            },
            // 6. order ata
            {
                pubkey: (0, index_js_2.getAta)(orderAccount, immutables.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 7. escrow
            {
                pubkey: escrowAddress,
                isSigner: false,
                isWritable: true
            },
            // 8. escrow ata
            {
                pubkey: (0, index_js_2.getAta)(escrowAddress, immutables.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 9. associated_token_program
            {
                pubkey: index_js_1.SolanaAddress.ASSOCIATED_TOKE_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            },
            // 10. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 11. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    withdrawPrivate(params, secret, extra) {
        const data = SvmSrcEscrowFactory.coder.instruction.encode('withdraw', {
            secret
        });
        const escrowAddress = this.getEscrowAddress(params);
        return new instruction_js_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: params.taker,
                isSigner: true,
                isWritable: true
            },
            // 2. maker asset
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 3. escrow
            {
                pubkey: escrowAddress,
                isWritable: true,
                isSigner: false
            },
            // 4. escrow ata
            {
                pubkey: (0, index_js_2.getAta)(escrowAddress, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 5. taker ata
            {
                pubkey: (0, index_js_2.getAta)(params.taker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 6. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 7. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    withdrawPublic(params, secret, resolver, extra) {
        const whitelistProgram = extra.whitelistProgramId
            ? new whitelist_js_1.WhitelistContract(extra.whitelistProgramId)
            : whitelist_js_1.WhitelistContract.DEFAULT;
        const data = SvmSrcEscrowFactory.coder.instruction.encode('publicWithdraw', {
            secret
        });
        const escrowAddress = this.getEscrowAddress(params);
        return new instruction_js_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: params.taker,
                isSigner: false,
                isWritable: true
            },
            // 2. payer
            {
                pubkey: resolver,
                isSigner: true,
                isWritable: true
            },
            // 3. resolver_access
            {
                pubkey: whitelistProgram.getAccessAccount(resolver),
                isSigner: false,
                isWritable: false
            },
            // 4. mint
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 5. escrow
            {
                pubkey: escrowAddress,
                isWritable: true,
                isSigner: false
            },
            // 6. escrow ata
            {
                pubkey: (0, index_js_2.getAta)(escrowAddress, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 7. taker ata
            {
                pubkey: (0, index_js_2.getAta)(params.taker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 8. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 9. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    /**
     * Cancel fill escrow private
     */
    cancelPrivate(params, extra) {
        const data = SvmSrcEscrowFactory.coder.instruction.encode('cancelEscrow', {});
        const escrowAddress = this.getEscrowAddress(params);
        if (extra.assetIsNative) {
            (0, assert_1.default)(params.token.equal(index_js_1.SolanaAddress.WRAPPED_NATIVE), 'assetIsNative can be true only when underlying asset is WSOL');
        }
        return new instruction_js_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: params.taker,
                isSigner: true,
                isWritable: true
            },
            // 2. maker
            {
                pubkey: params.maker,
                isSigner: false,
                isWritable: true
            },
            // 3. mint
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 4. escrow
            {
                pubkey: escrowAddress,
                isSigner: false,
                isWritable: true
            },
            // 5. escrow_ata
            {
                pubkey: (0, index_js_2.getAta)(escrowAddress, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 6. maker_ata (optional)
            this.optionalAccount({
                pubkey: (0, index_js_2.getAta)(params.maker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, extra.assetIsNative),
            // 7. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 8. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    /**
     * Cancel fill escrow public
     */
    cancelPublic(params, payer, extra) {
        const whitelistProgram = extra.whitelistProgramId
            ? new whitelist_js_1.WhitelistContract(extra.whitelistProgramId)
            : whitelist_js_1.WhitelistContract.DEFAULT;
        const data = SvmSrcEscrowFactory.coder.instruction.encode('publicCancelEscrow', {});
        if (extra.assetIsNative) {
            (0, assert_1.default)(params.token.equal(index_js_1.SolanaAddress.WRAPPED_NATIVE), 'assetIsNative can be true only when underlying asset is WSOL');
        }
        const escrowAddress = this.getEscrowAddress(params);
        return new instruction_js_1.Instruction(this.programId, [
            // 1. taker
            {
                pubkey: params.taker,
                isSigner: false,
                isWritable: true
            },
            // 2. maker
            {
                pubkey: params.maker,
                isSigner: false,
                isWritable: true
            },
            // 3. mint
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 4. payer
            {
                pubkey: payer,
                isSigner: true,
                isWritable: true
            },
            // 5. resolver_access
            {
                pubkey: whitelistProgram.getAccessAccount(payer),
                isSigner: false,
                isWritable: false
            },
            // 6. escrow
            {
                pubkey: escrowAddress,
                isSigner: false,
                isWritable: true
            },
            // 7. escrow_ata
            {
                pubkey: (0, index_js_2.getAta)(escrowAddress, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 8. maker_ata (optional)
            this.optionalAccount({
                pubkey: (0, index_js_2.getAta)(params.maker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, extra.assetIsNative),
            // 9. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 10. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    cancelOwnOrder(params, extra) {
        const data = SvmSrcEscrowFactory.coder.instruction.encode('cancelOrder', {});
        const orderAccount = this.getOrderAccount(params.orderHash);
        if (extra.assetIsNative) {
            (0, assert_1.default)(params.token.equal(index_js_1.SolanaAddress.WRAPPED_NATIVE), 'assetIsNative can be true only when underlying asset is WSOL');
        }
        return new instruction_js_1.Instruction(this.programId, [
            // 1. creator
            {
                pubkey: params.maker,
                isSigner: true,
                isWritable: true
            },
            // 2. mint
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 3. order
            {
                pubkey: orderAccount,
                isSigner: false,
                isWritable: true
            },
            // 4. order_ata
            {
                pubkey: (0, index_js_2.getAta)(orderAccount, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 5. creator_ata (optional)
            this.optionalAccount({
                pubkey: (0, index_js_2.getAta)(params.maker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, extra.assetIsNative),
            // 6. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 7. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
    cancelOrderByResolver(params, extra) {
        const whitelistProgram = extra.whitelistProgram ?? whitelist_js_1.WhitelistContract.DEFAULT;
        const data = SvmSrcEscrowFactory.coder.instruction.encode('cancelOrderByResolver', {
            rewardLimit: new bn_js_1.BN(params.rewardLimit.toString())
        });
        const orderAccount = this.getOrderAccount(params.orderHash);
        if (extra.assetIsNative) {
            (0, assert_1.default)(params.token.equal(index_js_1.SolanaAddress.WRAPPED_NATIVE), 'assetIsNative can be true only when underlying asset is WSOL');
        }
        return new instruction_js_1.Instruction(this.programId, [
            // 1. resolver
            {
                pubkey: params.resolver,
                isSigner: true,
                isWritable: true
            },
            // 2. resolver_access
            {
                pubkey: whitelistProgram.getAccessAccount(params.resolver),
                isSigner: false,
                isWritable: false
            },
            // 3. creator
            {
                pubkey: params.maker,
                isSigner: false,
                isWritable: true
            },
            // 4. mint
            {
                pubkey: params.token,
                isSigner: false,
                isWritable: false
            },
            // 5. order
            {
                pubkey: orderAccount,
                isSigner: false,
                isWritable: true
            },
            // 6. order_ata
            {
                pubkey: (0, index_js_2.getAta)(orderAccount, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            },
            // 7. creator_ata (optional)
            this.optionalAccount({
                pubkey: (0, index_js_2.getAta)(params.maker, params.token, extra.tokenProgramId),
                isSigner: false,
                isWritable: true
            }, extra.assetIsNative),
            // 8. token_program
            {
                pubkey: extra.tokenProgramId,
                isSigner: false,
                isWritable: false
            },
            // 9. system_program
            {
                pubkey: index_js_1.SolanaAddress.SYSTEM_PROGRAM_ID,
                isSigner: false,
                isWritable: false
            }
        ], data);
    }
}
exports.SvmSrcEscrowFactory = SvmSrcEscrowFactory;
//# sourceMappingURL=svm-src-escrow-factory.js.map