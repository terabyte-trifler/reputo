import { AuctionCalculator, EIP712TypedData, Extension, LimitOrderV4Struct } from '@1inch/fusion-sdk';
import { EvmCrossChainOrderInfo, EvmDetails, EvmEscrowParams, EvmExtra } from './types.js';
import { EscrowExtension } from './escrow-extension.js';
import { AddressLike, EvmAddress } from '../../domains/addresses/index.js';
import { BaseOrder } from '../base-order.js';
import { SupportedChain } from '../../chains.js';
import { HashLock } from '../../domains/hash-lock/index.js';
import { TimeLocks } from '../../domains/time-locks/index.js';
export declare class EvmCrossChainOrder extends BaseOrder<EvmAddress, LimitOrderV4Struct> {
    private inner;
    private constructor();
    get hashLock(): HashLock;
    get timeLocks(): TimeLocks;
    get srcSafetyDeposit(): bigint;
    get dstSafetyDeposit(): bigint;
    get dstChainId(): SupportedChain;
    get escrowExtension(): EscrowExtension;
    get extension(): Extension;
    get maker(): EvmAddress;
    get takerAsset(): AddressLike;
    get makerAsset(): EvmAddress;
    get takingAmount(): bigint;
    get makingAmount(): bigint;
    get salt(): bigint;
    /**
     * Real receiver of funds on dst chain
     */
    get receiver(): AddressLike;
    /**
     * Timestamp in sec
     */
    get deadline(): bigint;
    /**
     * Timestamp in sec
     */
    get auctionStartTime(): bigint;
    /**
     * Timestamp in sec
     */
    get auctionEndTime(): bigint;
    get nonce(): bigint;
    get partialFillAllowed(): boolean;
    get multipleFillsAllowed(): boolean;
    /**
     * Create new EvmCrossChainOrder
     */
    static new(escrowFactory: EvmAddress, orderInfo: EvmCrossChainOrderInfo, escrowParams: EvmEscrowParams, details: EvmDetails, extra?: EvmExtra): EvmCrossChainOrder;
    /**
     * Create CrossChainOrder from order data and extension
     *
     */
    static fromDataAndExtension(order: LimitOrderV4Struct, extension: Extension): EvmCrossChainOrder;
    build(): LimitOrderV4Struct;
    toJSON(): LimitOrderV4Struct;
    getOrderHash(srcChainId: number): string;
    getOrderHashBuffer(srcChainId: number): Buffer;
    getTypedData(srcChainId: number): EIP712TypedData;
    getCalculator(): AuctionCalculator;
    /**
     * Check if `wallet` can fill order before other
     */
    isExclusiveResolver(wallet: EvmAddress): boolean;
    /**
     * Check if the auction has exclusive resolver, and it is in the exclusivity period
     *
     * @param time timestamp to check, `now()` by default
     */
    isExclusivityPeriod(time: bigint): boolean;
    /**
     * Check whether address allowed to execute order at the given time
     *
     * @param executor address of executor
     * @param executionTime timestamp in sec at which order planning to execute
     */
    canExecuteAt(executor: EvmAddress, executionTime: bigint): boolean;
}
